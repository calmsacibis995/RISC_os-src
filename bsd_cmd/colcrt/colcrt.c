/*
 * |-----------------------------------------------------------|
 * | Copyright (c) 1990 MIPS Computer Systems, Inc.            |
 * | All Rights Reserved                                       |
 * |-----------------------------------------------------------|
 * |          Restricted Rights Legend                         |
 * | Use, duplication, or disclosure by the Government is      |
 * | subject to restrictions as set forth in                   |
 * | subparagraph (c)(1)(ii) of the Rights in Technical        |
 * | Data and Computer Software Clause of DFARS 52.227-7013.   |
 * |         MIPS Computer Systems, Inc.                       |
 * |         928 Arques Avenue                                 |
 * |         Sunnyvale, CA 94086                               |
 * |-----------------------------------------------------------|
 */
#ident	"$Header: colcrt.c,v 1.2.1.4 90/05/10 20:09:54 wje Exp $"

/*
 * Copyright (c) 1980 Regents of the University of California.
 * All rights reserved.  The Berkeley software License Agreement
 * specifies the terms and conditions for redistribution.
 */

#ifndef lint
char copyright[] =
"@(#) Copyright (c) 1980 Regents of the University of California.\n\
 All rights reserved.\n";
#endif not lint

#ifndef lint
static char sccsid[] = "@(#)colcrt.c	5.1 (Berkeley) 5/31/85";
#endif not lint

#include <stdio.h>
/*
 * colcrt - replaces col for crts with new nroff esp. when using tbl. Bill
 * Joy UCB July 14, 1977 
 *
 * This filter uses a screen buffer, 267 half-lines by 132 columns. It
 * interprets the up and down sequences generated by the new nroff when used
 * with tbl and by \u \d and \r. General overstriking doesn't work correctly.
 * Underlining is split onto multiple lines, etc. 
 *
 * Option - suppresses all underlining. Option -2 forces printing of all half
 * lines. 
 */

#define LINELEN		132
#define HALFLINES	267

char            page[HALFLINES][LINELEN];

int             outline = 1;
int             outcol;

char            suppresul;
char            printall;
char            dontsplitbl;

char           *progname;
FILE           *f;

main(argc, argv)
	int             argc;
	char           *argv[];
{
	register        c;
	register char  *cp, *dp;

	argc--;
	progname = *argv++;
	while (argc > 0 && argv[0][0] == '-') {
		switch (argv[0][1]) {
		case 0:
			suppresul = 1;
			break;
		case '2':
			printall = 1;
			break;
		case 'b':
			dontsplitbl = 1;
			break;
		default:
			printf("usage: %s [ - ] [ -2 ] [ -b ] [ file ... ]\n", progname);
			fflush(stdout);
			exit(1);
		}
		argc--;
		argv++;
	}
	do {
		if (argc > 0) {
			close(0);
#ifdef RISCOS
			if ((f = fopen(argv[0], "r")) != NULL)
#else
			if ((f = fopen(argv[0], "r")) < 0)
#endif
			{
				fflush(stdout);
				perror(argv[0]);
				fflush(stdout);
				exit(1);
			}
			argc--;
			argv++;
		}
		for (;;) {
			c = getc(stdin);
			if (c == -1) {
				pflush(outline);
				fflush(stdout);
				break;
			}
			switch (c) {
			case '\n':
				if (outline >= (HALFLINES - 2))
					pflush(62);
				outline += 2;
				outcol = 0;
				continue;
			case '\016':
			case '\017':
				continue;
			case 033:
				c = getc(stdin);
				switch (c) {
				case '9':
					if (outline >= (HALFLINES - 1))
						pflush(62);
					outline++;
					continue;
				case '8':
					if (outline >= 1)
						outline--;
					continue;
				case '7':
					outline -= 2;
					if (outline < 0)
						outline = 0;
					continue;
				default:
					continue;
				}
			case '\b':
				if (outcol)
					outcol--;
				continue;
			case '\t':
				outcol += 8;
				outcol &= ~7;
				outcol--;
				c = ' ';
			default:
				if (outcol >= LINELEN) {
					outcol++;
					continue;
				}
				cp = &page[outline][outcol];
				outcol++;
				if (c == '_') {
					if (suppresul)
						continue;
					cp += LINELEN;
					c = '-';
				}
				if (*cp == 0) {
					*cp = c;
					dp = cp - outcol;
					for (cp--; cp >= dp && *cp == 0; cp--)
						*cp = ' ';
				} else if (plus(c, *cp) || plus(*cp, c))
					*cp = '+';
				else if (*cp == ' ' || *cp == 0)
					*cp = c;
				continue;
			}
		}
	} while (argc > 0);
	fflush(stdout);
	exit(0);
}

plus(c, d)
	char            c, d;
{

	return (c == '|' && d == '-' || d == '_');
}

int             first;

pflush(ol)
	int             ol;
{
	register int    i, j;
	register char  *cp;
	char            lastomit;
	int             l;

	l = ol;
	lastomit = 0;
	if (l > (HALFLINES - 1))
		l = (HALFLINES - 1);
	else
		l |= 1;
	for (i = first | 1; i < l; i++) {
		move(i, i - 1);
		move(i, i + 1);
	}
	for (i = first; i < l; i++) {
		if (dontsplitbl && i % 2 != 0 && canmerge(page[i], page[i + 1]))
			merge(page[i], page[i + 1]);
		cp = page[i];
		if (printall == 0 && lastomit == 0 && *cp == 0) {
			lastomit = 1;
			continue;
		}
		lastomit = 0;
		printf("%s\n", cp);
	}
	bcopy(page[ol], page, (HALFLINES - ol) * LINELEN);
	bzero(page[HALFLINES - ol], ol * LINELEN);
	outline -= ol;
	outcol = 0;
	first = 1;
}
move(l, m)
	int             l, m;
{
	register char  *cp, *dp;

	for (cp = page[l], dp = page[m]; *cp; cp++, dp++) {
		switch (*cp) {
		case '|':
			if (*dp != ' ' && *dp != '|' && *dp != 0)
				return;
			break;
		case ' ':
			break;
		default:
			return;
		}
	}
	if (*cp == 0) {
		for (cp = page[l], dp = page[m]; *cp; cp++, dp++)
			if (*cp == '|')
				*dp = '|';
			else if (*dp == 0)
				*dp = ' ';
		page[l][0] = 0;
	}
}


/*
 * Check for being able to merge _ with a blank, so that 
 */

int
canmerge(a, b)
	char            a[LINELEN], b[LINELEN];
{
	register int    i;
	for (i = 0; a[i] && b[i] && i < LINELEN; i++) {
		if ((' ' != a[i] || '-' != b[i]) && ' ' != b[i]) {
			return 0;
		}
	}
	return 1;
}

merge(a, b)
	char            a[LINELEN], b[LINELEN];
{
	register int    i;
	for (i = 0; b[i] && i < LINELEN; i++) {
		if (' ' == a[i] || !a[i])
			a[i] = '-' == b[i] ? '_' : b[i];
	}
	bzero(b, LINELEN);
}
